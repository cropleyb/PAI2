How to unit test pai2?

Components
----------
AlphaBeta - Mock out Bridge as template

Move Suggestor
Utility Calculator
Utility Stats
Game State
ABBridge? Or is this the Game/Game State?

US
--
board locations: (these are shared with move suggestor)
total counts/length for each player
  "      "  /caps    "    "    "
  "      "  /threats "    "    "

other measurements:
caps for each player (should also be used by move suggestor)
  "      "  /enc. 4s "    "    "
chessboard counts

Index + BoardStrip -> Loc
start of strip + direction * index
can this be done with ints? probably :)

who calls who?
Game::make move
    setOcc
		before - iterate over masks for board strip
			length lookup table access
			convert indices to Locs
			update move suggestor/utility data
		update board strip data (place/capture 1 piece)
		after - iterate over masks for board strip
			length lookup table access
			convert indices to Locs
			update move suggestor/utility data

/LengthLookupTable -> LineLookupTable
 / lineLookupTable is a raw array of LinePatterns, keyed on 10 bit patterns
 / add support for takes, threats, half-blocked 4s
BoardDirectionRep
 - 2d array of U64[MAX_DIRS][2*MAX_CANDS]
 - bit representation of whole board
 - direction (Loc offset)
 - convert from ind to Loc and back (via SpanEntry)
 - beforeSetOcc(loc, colour, posStats)
 - afterSetOcc(loc, colour, posStats)
 - Uses lengthLookupTable
// BoardReps
 // - 4x BoardDirectionReps
 // - setOcc(loc, colour, posStats)
Game
 - BoardRep
/PriorityLevel
 - Priority levels must be searched in order of decreasing counts per candidate
 - Sort on demand. Quicksort variant? Natural Merge sort?
 - Dirty bit
PositionStats
 /- PriorityLevel * 4 for line lengths
 /- PriorityLevel * 2 for takes and threats
 /- report(span, pattern, colour) converts pattern indices to locs
 /- Captured counts
 - Chessboard counts
/CandidateCache
 /- max depth * max breadth array of Locs
 /- max depth * number of Locs
 /- max depth * next Loc index
/ MoveSuggestor = old PriorityFilter
 /- All except PL sorting
/AlphaBeta
 /- first cut
/SpanLookupTable
 /- Array of SpanEntries (1 per Loc on the board)
 /- Each describes the line that the Loc is on (strip, min, max, etc.)
 /- Converts between index on that line and Locs

BoardStrip indices to Locs during pattern reporting
---------------------------------------------------
- PatternLookupTable passed to matching loop.
  contains entries for each pattern (pre-built)
  same length (5) for everything
  duplicate entries for "don't care" points
  edge matching?
  - struct for LineEntry?
  - LinePattern types (cands): Take (1), Threat (2), Length (5-n), HalfBlocked4 (0)
  - array of indices of candidates?
- ind2loc func passed into matcher too? No, one level up.
- array of Locs passed to reporting function
- Matcher templated on Reporter, contains one instance
- Reporter takes conversion func/obj in each reporting method, passed from match()
- is this a DirectionStrip?

Game.makeMove(Loc)
    checkForCaptures(Loc)
	for each direction
		(DirectionStrip)
		captures.extend(process_direction_captures(ds, move_pos, MC)
	for each direction
		(DirectionStrip)
        lookup Span in array by Loc: ds index, min, max, loc index, base loc, direction loc per index val
		before set occ
		    (LineMatcher)
		    match(U64, ds, span, inc = -1)
			    (Uses singleton? LineLookupTable)
			    for each match
			        reporter.report(LineEntry, index offset, ds, inc)
					    (Reporter)
						Use ds to convert indices to Locs
						switch on LineEntry type
						PositionStats.report*(Locs)
		set occ(from span, colour)
		after set occ
		    match(inc = 1)
			    (as above)
		    

Threats & Line2s
How to deal with threats in the lookup table?
Most (but not all) threats are also Line2s.
Lookup a second table if we detect a Threat, and report that too.

Edges for diagonal reps need different length EDGEs.
Iterate through each strip. Iterate around the 4 edges to get all the
SpanEntries. Lookup _maxIndex, and call setOcc(EDGE)

empty board is not empty - (0,0) is P1 (?)
Line1 is being subtracted from first.
dir not incrementing in span_lookup_table loop???
which dir is causing the problem?
- turns out that the board strips were not being initialised in the constructor.

How to create a PenteGame instance
----------------------------------
Alph-Beta just needs to know about the PG instance, not the other way around.
PG contains BoardReps, PositionStats, MoveSuggester, MoveHistory

Capture flow
------------
PenteGame makeMove
  short circuit - must be a Take for that Loc in the PositionStats
  checks for pattern match in each direction
  report to PositionStats in same way as for Line1 etc.?
  Must also report or return the captures back to PenteGame to call setOcc and update the MoveHistory.
  MH needs the Locs, PosStats only needs a total count, so PG should do the conversions to Locs, and report to the PosStats.
  Or PG should pass in a Loc buffer (from MH) to BoardReps for it to populate.

UtilCalc accessing PS
---------------------
Template UC on PS - so we can mock PS for unit tests
But how will UC use PS? friend class?
UC (currently) just uses the counts of patterns for each player

Putting it all together
-----------------------
Create ABBridge, which contains the PenteGame.
Or use PenteGame as the bridge, by deriving it from IABBridge?
Unit Test get next move, utility etc.

Subsystem tests
---------------
test_dont_waste_a_pair:

Assertion failed: (l._value<=MAX_LOCS), function setOcc, file /Users/cropleyb/Dropbox/pai2/src/board_reps.cpp, line 68.

setOcc is being passed a Loc::INVALID

Remaining
---------
/ sorting candidates per level in the priority levels
checkerboard
half-blocked to PosStats
/ half-blocked scoring
optimise transposition table to reduce copying for store?
CMD line interface?
Integrate with python code
Configuration a la AIGenome
Test turning off the TT?

Crash???
--------
What's going on?

[ RUN      ] AISubsystemFixture.test_strange
Assertion failed: (l._value>=0), function setOcc, file /Users/cropleyb/Dropbox/pai2/src/board_reps.cpp, line 61.
 P1 P2 P1 P2 P1 P2 P1/bin/bash: line 1: 90981 Abort trap: 6           debug/tests

This is coming from the MoveSuggester. How is it getting there?
I thought this was working?
- Debug it
1. More asserts
- Analyse source
- Analyse source changes

Which PriorityLevel class is best:
- unsorted. lower playing ability than pai1
- sorted by separate dirty bit sort call. Messy?
- sorted incrementally. yes

- node indexed by Loc directly (array) - is this the slowdown? probably.
- node indexed by Loc indirectly (sep. array). yes

Based on:
PriorityLevel - easier? Hmmm.
PriorityLevel2 - yeah

LengthLookupTable
4 ** 5 = 2 ** 10 = 1024 slots - lots of lookups.
Quick check: 1024 bits = 32 slots of 32 bit uints.

Use from python code
--------------------
/ String based API in the C++ code.
Build a library with CMake first? static lib? dynamic lib?
Or build the C++ code directly from setup.py as a cython extension?
NOGIL? Yes! Yay!

./tests --gtest_filter="*bad*" > bad.txt

What next?
----------
run AI equiv. for C++ code
Use run_ai.py to compare Py and C++ AIs
  - Add support for other board sizes
  - Pass more params to pai2: standard vs tournament
Include py openings DB
...Port openings DB to C++ for Pente.org? when needed...
// Analyse some more bad play.
// Add sort of lowest level of included PL candidates (by decreasing count)

AB extra pruning?
initiative detection
Fukami in utility score?
More detailed opening strategy
restrict getPriorityLevels when there is an opponent's open 3, and boost the depth for that branch.

2 searches: wide & shallow; narrow & deep?

VCT
trigger at max depth, if we have the initiative?
e.g.
we have a 3, they don't have a 4, and it is our move, just search our 3s.
we have a 3, they don't have a 3, and it is their move, they just search our 3s.
our best level and their best level
if OBL == TBL, initiative == to move
what is important about OBL and TBL is the number of moves to win -
if OBL is 4 then it is one Turn To Win. (TTW)
Does one player always have the initiative?

When should a VCT search be stopped?
// Ours:
When the initiative is reversed?

How do we incorporate VCT and non-VCT search?
ie the VCT search may not give the best position for the player who initiated it.

e.g. at (even) maxdepth. P1 search, P1's turn. Both P1 and P2 have 3s, but no 4s
so P1 has the initiative.
P1 VCT can search all Line3 moves, and choose the AB best cf. the utility at that maxdepth position
maxdepth+1: (odd depth).  P1 search, P2's turn. P2 Must block the 4(s) (or capture it/them)
Termination conds: game won. No more P1 3s to extend.

Loss by continuous threats:
e.g. at (even) maxdepth. P1 search, P1's turn. P2 has a 4
so P2 has the initiative.
P2 VCT can search all Line3 moves, and choose the AB best cf. the utility at that maxdepth position
maxdepth+1: (odd depth).  P1 search, P1's turn. P1 Must block the 4(s) (or capture it/them)
Termination conds: game lost. No more P2 3s to extend.

3 VCTs
P1 (to move): 2xLine3; P2: 3xLine3 inc. 2 doubles

For each player:
If #4s > 0
	TTW = 1
If #takes > 0 && #captured >= 8
	TTW = 1
If #3s > 0
	TTW = 2
If #threats > 0 && #captured >= 8
	TTW = 2
If #takes > 1 && #captured >= 6
    // Assuming the first take opens up a second?
	TTW = 2

When to include the emergency level:
Depth 0 - always need at least one move.
Depth 1..maxDepth-1 - no; the utility func should determine these positions as won or lost, and save some searching(?)
Depth maxDepth - no; this one
Depth >maxDepth (i.e. VCT) - no

when should we call the util func? max depth and max VCT depth?
// VCT positions with the initiative? #Their4s==0, #OurLine3s>0, #OurTakes>1 and caps >= 6
Or VCT posns. where we are not forced? NOT(#Their4s==0 or #TheirTakes>0 and #theirCaps >= 8)
Or positions with no move suggestions.

When do we need to do more search?


Rename cutoff?
